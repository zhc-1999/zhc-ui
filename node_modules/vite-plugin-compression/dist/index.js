var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/index.ts
__export(exports, {
  default: () => src_default
});
var import_path2 = __toModule(require("path"));
var import_vite = __toModule(require("vite"));

// src/utils.ts
var import_fs = __toModule(require("fs"));
var import_path = __toModule(require("path"));
var isFunction = (arg) => typeof arg === "function";
var isRegExp = (arg) => Object.prototype.toString.call(arg) === "[object RegExp]";
function readAllFile(root, reg) {
  let resultArr = [];
  try {
    if (import_fs.default.existsSync(root)) {
      const stat = import_fs.default.lstatSync(root);
      if (stat.isDirectory()) {
        const files = import_fs.default.readdirSync(root);
        files.forEach(function(file) {
          const t = readAllFile(import_path.default.join(root, "/", file), reg);
          resultArr = resultArr.concat(t);
        });
      } else {
        if (reg !== void 0) {
          if (isFunction(reg.test) && reg.test(root)) {
            resultArr.push(root);
          }
        } else {
          resultArr.push(root);
        }
      }
    }
  } catch (error) {
  }
  return resultArr;
}

// src/index.ts
var import_fs_extra = __toModule(require("fs-extra"));
var import_chalk = __toModule(require("chalk"));
var import_zlib = __toModule(require("zlib"));
var import_debug = __toModule(require("debug"));
var debug = (0, import_debug.debug)("vite-plugin-compression");
var extRE = /\.(js|mjs|json|css|html)$/i;
var mtimeCache = new Map();
var exportFn = (options = {}) => {
  let outputPath;
  let config;
  const emptyPlugin = {
    name: "vite:compression"
  };
  const {
    disable = false,
    filter = extRE,
    verbose = true,
    algorithm = "gzip",
    ext = ".gz",
    threshold = 1025,
    compressionOptions = {},
    deleteOriginFile = false,
    success = () => {
    }
  } = options;
  if (disable) {
    return emptyPlugin;
  }
  debug("plugin options:", options);
  return __spreadProps(__spreadValues({}, emptyPlugin), {
    apply: "build",
    enforce: "post",
    configResolved(resolvedConfig) {
      config = resolvedConfig;
      outputPath = import_path2.default.isAbsolute(config.build.outDir) ? config.build.outDir : import_path2.default.join(config.root, config.build.outDir);
      debug("resolvedConfig:", resolvedConfig);
    },
    async closeBundle() {
      let files = readAllFile(outputPath) || [];
      debug("files:", files);
      if (!files.length)
        return;
      files = filterFiles(files, filter);
      const compressOptions = getCompressionOptions(algorithm, compressionOptions);
      const compressMap = new Map();
      const handles = files.map(async (filePath) => {
        let { mtimeMs, size: oldSize } = await import_fs_extra.default.stat(filePath);
        if (mtimeMs <= (mtimeCache.get(filePath) || 0) || oldSize < threshold)
          return;
        let content = await import_fs_extra.default.readFile(filePath);
        if (deleteOriginFile) {
          import_fs_extra.default.remove(filePath);
        }
        try {
          content = await compress(content, algorithm, compressOptions);
        } catch (error) {
          config.logger.error("compress error:" + filePath);
        }
        const size = content.byteLength;
        const cname = getOutputFileName(filePath, ext);
        compressMap.set(filePath, {
          size: size / 1024,
          oldSize: oldSize / 1024,
          cname
        });
        await import_fs_extra.default.writeFile(cname, content);
        mtimeCache.set(filePath, Date.now());
      });
      Promise.all(handles).then(() => {
        if (verbose) {
          handleOutputLogger(config, compressMap, algorithm);
          success();
        }
      });
    }
  });
};
function filterFiles(files, filter) {
  if (filter) {
    const isRe = isRegExp(filter);
    const isFn = isFunction(filter);
    files = files.filter((file) => {
      if (isRe) {
        return filter.test(file);
      }
      if (isFn) {
        return filter(file);
      }
      return true;
    });
  }
  return files;
}
function getCompressionOptions(algorithm = "", compressionOptions = {}) {
  const defaultOptions = {
    gzip: {
      level: import_zlib.default.constants.Z_BEST_COMPRESSION
    },
    deflate: {
      level: import_zlib.default.constants.Z_BEST_COMPRESSION
    },
    deflateRaw: {
      level: import_zlib.default.constants.Z_BEST_COMPRESSION
    },
    brotliCompress: {
      params: {
        [import_zlib.default.constants.BROTLI_PARAM_QUALITY]: import_zlib.default.constants.BROTLI_MAX_QUALITY,
        [import_zlib.default.constants.BROTLI_PARAM_MODE]: import_zlib.default.constants.BROTLI_MODE_TEXT
      }
    }
  };
  return __spreadValues(__spreadValues({}, defaultOptions[algorithm]), compressionOptions);
}
function compress(content, algorithm, options = {}) {
  return new Promise((resolve, reject) => {
    import_zlib.default[algorithm](content, options, (err, result) => err ? reject(err) : resolve(result));
  });
}
function getOutputFileName(filepath, ext) {
  const compressExt = ext.startsWith(".") ? ext : `.${ext}`;
  return `${filepath}${compressExt}`;
}
function handleOutputLogger(config, compressMap, algorithm) {
  config.logger.info(`
${import_chalk.default.cyan("\u2728 [vite-plugin-compression]:algorithm=" + algorithm)} - compressed file successfully: `);
  const keyLengths = Array.from(compressMap.keys(), (name) => name.length);
  const maxKeyLength = Math.max(...keyLengths);
  compressMap.forEach((value, name) => {
    let { size, oldSize, cname } = value;
    const rName = (0, import_vite.normalizePath)(cname).replace((0, import_vite.normalizePath)(`${config.root}/${config.build.outDir}/`), "");
    const sizeStr = `${oldSize.toFixed(2)}kb / ${algorithm}: ${size.toFixed(2)}kb`;
    config.logger.info(import_chalk.default.dim(config.build.outDir + "/") + import_chalk.default.blueBright(rName) + " ".repeat(2 + maxKeyLength - name.length) + " " + import_chalk.default.dim(sizeStr));
  });
  config.logger.info("\n");
}
module.exports = exportFn;
var src_default = exportFn;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
