import { defineComponent, ref, computed, unref, resolveComponent, openBlock, createBlock, mergeProps, withCtx, createElementBlock, toDisplayString, createCommentVNode, renderSlot, createTextVNode } from 'vue';
import { ElTooltip } from '../../tooltip/index.mjs';
import '../../popper/index.mjs';
import '../../../utils/util.mjs';
import { usePopoverProps } from './popover.mjs';
import _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';
import { isString } from '@vue/shared';
import { useDeprecateAppendToBody } from '../../popper/src/deprecation.mjs';

const emits = ["update:visible", "after-enter", "after-leave"];
const COMPONENT_NAME = "ElPopover";
const _sfc_main = defineComponent({
  name: COMPONENT_NAME,
  components: {
    ElTooltip
  },
  props: usePopoverProps,
  emits,
  setup(props, { emit }) {
    const tooltipRef = ref(null);
    const popperRef = computed(() => {
      var _a;
      return (_a = unref(tooltipRef)) == null ? void 0 : _a.popperRef;
    });
    const width = computed(() => {
      if (isString(props.width)) {
        return props.width;
      }
      return `${props.width}px`;
    });
    const style = computed(() => {
      return [
        {
          width: width.value
        },
        props.popperStyle
      ];
    });
    const kls = computed(() => {
      return [
        { "el-popover--plain": !!props.content },
        "el-popover",
        props.popperClass
      ];
    });
    const { compatTeleported } = useDeprecateAppendToBody(COMPONENT_NAME, "appendToBody");
    const hide = () => {
      var _a;
      (_a = tooltipRef.value) == null ? void 0 : _a.hide();
    };
    const afterEnter = () => {
      emit("after-enter");
    };
    const afterLeave = () => {
      emit("after-leave");
    };
    return {
      compatTeleported,
      kls,
      style,
      tooltipRef,
      popperRef,
      hide,
      afterEnter,
      afterLeave
    };
  }
});
const _hoisted_1 = {
  key: 0,
  class: "el-popover__title",
  role: "title"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tooltip = resolveComponent("el-tooltip");
  return openBlock(), createBlock(_component_el_tooltip, mergeProps({ ref: "tooltipRef" }, _ctx.$attrs, {
    "aria-label": _ctx.title,
    effect: _ctx.effect,
    enterable: _ctx.enterable,
    "popper-class": _ctx.kls,
    "popper-style": _ctx.style,
    teleported: _ctx.compatTeleported,
    persistent: "",
    onShow: _ctx.afterEnter,
    onHide: _ctx.afterLeave
  }), {
    content: withCtx(() => [
      _ctx.title ? (openBlock(), createElementBlock("div", _hoisted_1, toDisplayString(_ctx.title), 1)) : createCommentVNode("v-if", true),
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.content), 1)
      ])
    ]),
    default: withCtx(() => [
      _ctx.$slots.reference ? renderSlot(_ctx.$slots, "reference", { key: 0 }) : createCommentVNode("v-if", true)
    ]),
    _: 3
  }, 16, ["aria-label", "effect", "enterable", "popper-class", "popper-style", "teleported", "onShow", "onHide"]);
}
var Popover = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);

export { Popover as default };
//# sourceMappingURL=index.mjs.map
